//! # SiliconFlow module
//!
//! This module contains logic for the SiliconFlow API.

use super::{embedding::EmbeddingBytes, SenseError};
use base64::{Engine as _, engine::general_purpose::STANDARD as DECODER};
use doc_for::{doc_impl, DocDyn};
use reqwest::{Client, Url};
use serde::{Serialize, Deserialize};

// == API key and model definitions ==

/// Available models.
#[doc_impl(doc_for = false, doc_dyn = true, strip = 1)]
pub enum Model {
    /// BAAI/bge-large-zh-v1.5
    BgeLargeZhV1_5,
    /// BAAI/bge-large-en-v1.5
    BgeLargeEnV1_5,
    /// netease-youdao/bce-embedding-base_v1
    BceEmbeddingBaseV1,
    /// BAAI/bge-m3
    BgeM3,
    /// Pro/BAAI/bge-m3
    ProBgeM3,
}

impl Default for Model {
    fn default() -> Self {
        Self::BgeLargeZhV1_5
    }
}

/// An API key.
#[derive(Debug)]
pub struct ApiKey(String);

impl ApiKey {
    /// Create a new API key.
    fn new(key: String) -> Result<Self, SenseError> {
        // Check that the key is in the correct format:
        // `sk-` followed by 48 alphanumeric characters
        if key.len() != 51 {
            return Err(SenseError::MalformedApiKey);
        }
        for c in key.chars().skip(3) {
            if !c.is_ascii_alphanumeric() {
                return Err(SenseError::MalformedApiKey);
            }
        }

        Ok(Self(key))
    }
}

impl TryFrom<String> for ApiKey {
    type Error = SenseError;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}

// == Request and response definitions ==

/// The request body for the SiliconFlow API.
#[derive(Serialize)]
struct RequestBody<'a> {
    /// The model to use.
    model: &'a str,
    /// The input text.
    input: &'a str,
    /// The encoding format, either "float" or "base64".
    encoding_format: &'a str,
}

/// ResponseBody.data: The list of embeddings generated by the model.
#[derive(Deserialize)]
struct Data {
    /// Fixed string "embedding".
    #[serde(rename = "object")]
    _object: String,
    /// Base64-encoded embedding.
    embedding: String,
    /// Unused.
    #[serde(rename = "index")]
    _index: i32,
}

/// ResponseBody.usage: The usage information for the request.
#[derive(Deserialize)]
#[allow(dead_code, reason = "For deserialization only")]
struct Usage {
    /// The number of tokens used by the prompt.
    prompt_tokens: u32,
    /// The number of tokens used by the completion.
    completion_tokens: u32,
    /// The total number of tokens used by the request.
    total_tokens: u32,
}

/// The response body for the SiliconFlow API.
#[derive(Deserialize)]
struct ResponseBody {
    /// The name of the model used to generate the embedding.
    model: String,
    /// The list of embeddings generated by the model.
    data: Vec<Data>,
    /// The usage information for the request.
    #[serde(rename = "usage")]
    _usage: Usage,
}

// == API client ==

/// A client for the SiliconFlow API.
pub struct ApiClient {
    /// API key.
    key: String,
    /// The model to use.
    model: String,
    /// API endpoint.
    endpoint: Url,
    /// HTTP client.
    client: Client,
}

impl ApiClient {
    /// Create a new API client.
    pub fn new(key: ApiKey, model: Model) -> Self {
        Self {
            key: key.0,
            model: model.doc_dyn().unwrap().to_string(),
            endpoint: Url::parse("https://api.siliconflow.cn/v1/embeddings").unwrap(),
            client: Client::new(),
        }
    }

    /// Embed a text.
    pub async fn embed(&self, text: &str) -> Result<EmbeddingBytes, SenseError> {
        let request_body = RequestBody {
            model: &self.model,
            input: text,
            encoding_format: "base64",
        };

        let response: ResponseBody = self
            .client
            .post(self.endpoint.clone())
            .header("Authorization",
                    format!("Bearer {}", self.key))
            .json(&request_body)
            .send()
            .await?
            .json()
            .await?;

        assert_eq!(response.model, self.model);

        let embedding = DECODER.decode(response.data[0].embedding.as_bytes()).unwrap();
        Ok(embedding.try_into()?)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const KEY : &str = "sk-1234567890abcdef1234567890abcdef1234567890abcdef";

    #[test]
    fn test_api_key_ok() {
        let key = ApiKey::new(KEY.to_string());
        assert!(key.is_ok());
    }

    #[test]
    fn test_api_key_malformed() {
        let key = ApiKey::new("sk-1234567890abcdef1234567890abcdef1234567890abcde".to_string());
        let err = key.unwrap_err();
        assert!(matches!(err, SenseError::MalformedApiKey));
    }

    #[tokio::test]
    #[ignore = "requires API key in `SILICONFLOW_API_KEY` env var"]
    async fn test_embed() {
        // Read the API key from the environment
        let key = std::env::var("SILICONFLOW_API_KEY").unwrap();
        let client = ApiClient::new(
            ApiKey::try_from(key).unwrap(),
            Model::BgeLargeZhV1_5,
        );
        let embedding = client.embed("Hello, world!").await;
        let _ = embedding.unwrap();
    }
}
